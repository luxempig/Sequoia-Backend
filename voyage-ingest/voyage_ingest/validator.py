from __future__ import annotations

import os
import re
import logging
from typing import Dict, List, Set, Optional

from google.oauth2 import service_account
from googleapiclient.discovery import build

from voyage_ingest.slugger import slugify, normalize_source

LOG = logging.getLogger("voyage_ingest.validator")

DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")
# Capture groups: (date) - (president) - (descriptor)
VOYAGE_SLUG_CAPTURE_RE = re.compile(r"^(\d{4}-\d{2}-\d{2})-([a-z0-9-]+)-([a-z0-9-]+)$")
PERSON_SLUG_RE = re.compile(r"^[a-z0-9]+(?:-[a-z0-9]+)+(?:-[a-z0-9]+)?$")  # lastname-firstname[-suffix]
MEDIA_SLUG_RE_TMPL = r"^{date}-[a-z0-9-]+-{vslug}-\d{{2}}$"

VALID_VOYAGE_TYPES = {"official", "private", "maintenance", "other"}

# ---------------- Google Sheets helpers (presidents) ----------------

_SHEETS_SVC = None
_PRESIDENT_CACHE: Optional[Set[str]] = None

def _sheets_service():
    global _SHEETS_SVC
    if _SHEETS_SVC is not None:
        return _SHEETS_SVC
    creds_path = os.environ.get("GOOGLE_APPLICATION_CREDENTIALS", "").strip()
    if not creds_path or not os.path.exists(creds_path):
        raise RuntimeError("GOOGLE_APPLICATION_CREDENTIALS not set or invalid path for validator")
    creds = service_account.Credentials.from_service_account_file(
        creds_path,
        scopes=["https://www.googleapis.com/auth/spreadsheets.readonly"],
    )
    _SHEETS_SVC = build("sheets", "v4", credentials=creds)
    return _SHEETS_SVC

def _read_president_slugs_from_sheet() -> Set[str]:
    """
    Reads 'presidents' tab and returns a set of valid president_slug values.
    Uses env override PRESIDENTS_SHEET_TITLE if provided (default: 'presidents').
    """
    global _PRESIDENT_CACHE
    if _PRESIDENT_CACHE is not None:
        return _PRESIDENT_CACHE

    spreadsheet_id = os.environ.get("SPREADSHEET_ID", "").strip()
    if not spreadsheet_id:
        LOG.warning("SPREADSHEET_ID not set; skipping president slug validation")
        _PRESIDENT_CACHE = set()
        return _PRESIDENT_CACHE

    title = os.environ.get("PRESIDENTS_SHEET_TITLE", "presidents").strip() or "presidents"

    svc = _sheets_service()
    try:
        # Read whole sheet to find header + column
        res = svc.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"{title}!A:ZZ"
        ).execute()
        values = res.get("values", []) or []
        if not values:
            LOG.warning("Presidents sheet '%s' is empty; skipping president slug validation", title)
            _PRESIDENT_CACHE = set()
            return _PRESIDENT_CACHE

        header = [h.strip().lower() for h in values[0]]
        if "president_slug" not in header:
            LOG.warning("Presidents sheet missing 'president_slug' column; skipping validation")
            _PRESIDENT_CACHE = set()
            return _PRESIDENT_CACHE

        idx = header.index("president_slug")
        slugs: Set[str] = set()
        for row in values[1:]:
            if idx < len(row):
                s = row[idx].strip().lower()
                if s:
                    slugs.add(s)
        _PRESIDENT_CACHE = slugs
        LOG.info("Loaded %d president slug(s) for validation", len(slugs))
        return _PRESIDENT_CACHE
    except Exception as e:
        LOG.warning("Failed reading presidents sheet: %s; skipping president slug validation", e)
        _PRESIDENT_CACHE = set()
        return _PRESIDENT_CACHE

# ---------------- Basic field validators ----------------

def _req(d: Dict, key: str, path: str, errs: List[str]):
    if not (d.get(key) or "").strip():
        errs.append(f"[{path}] missing required field: {key}")

def _date(d: Dict, key: str, path: str, errs: List[str]):
    v = (d.get(key) or "").strip()
    if v and not DATE_RE.match(v):
        errs.append(f"[{path}] invalid date for {key}: {v} (YYYY-MM-DD)")

def _enum(d: Dict, key: str, allowed: set, path: str, errs: List[str]):
    v = (d.get(key) or "").strip().lower()
    if v and v not in allowed:
        errs.append(f"[{path}] invalid value for {key}: {v} (allowed: {sorted(allowed)})")

def _is_drive_file_link(s: str) -> bool:
    return "/file/d/" in (s or "")

# ---------------- Main bundle validation ----------------

def validate_bundle(bundle: Dict) -> List[str]:
    """
    Validates voyage + passengers + media.
    Media slug is expected to already be auto-generated by the parser.
    Also validates that voyage_slug's president matches the presidents sheet.
    """
    errs: List[str] = []
    v = bundle.get("voyage") or {}
    ppl = bundle.get("passengers") or []
    med = bundle.get("media") or []

    # ---- voyage fields
    _req(v, "voyage_slug", "voyage", errs)
    _req(v, "title", "voyage", errs)
    _req(v, "start_date", "voyage", errs)
    _date(v, "start_date", "voyage", errs)

    if v.get("end_date"):
        _date(v, "end_date", "voyage", errs)

    if v.get("voyage_type"):
        _enum(v, "voyage_type", VALID_VOYAGE_TYPES, "voyage", errs)

    vslug = (v.get("voyage_slug") or "").strip()
    if vslug:
        m = VOYAGE_SLUG_CAPTURE_RE.match(vslug)
        if not m:
            errs.append(f"[voyage] invalid voyage_slug format: {vslug} (expected YYYY-MM-DD-<president>-<descriptor>)")
        else:
            date_part, president_part, _descriptor = m.groups()
            # Optional: ensure year in slug matches start_date year
            sd = (v.get("start_date") or "")[:4]
            if sd and date_part[:4] != sd:
                errs.append(f"[voyage] voyage_slug year {date_part[:4]} != start_date year {sd}")

            # NEW: president must exist in presidents sheet
            allowed_presidents = _read_president_slugs_from_sheet()
            if allowed_presidents:
                if president_part not in allowed_presidents:
                    errs.append(f"[voyage] president '{president_part}' not found in presidents sheet (president_slug)")

    # ---- passengers
    for i, p in enumerate(ppl, start=1):
        path = f"passengers #{i}"
        _req(p, "slug", path, errs)
        _req(p, "full_name", path, errs)
        ps = (p.get("slug") or "").strip()
        if ps and not PERSON_SLUG_RE.match(ps):
            errs.append(f"[{path}] invalid person slug: {ps}")
        for field in ("birth_year", "death_year"):
            val = (p.get(field) or "").strip()
            if val and not val.isdigit():
                errs.append(f"[{path}] {field} must be an integer if provided")

    # ---- media (slugs auto-generated by parser)
    for i, m in enumerate(med, start=1):
        path = f"media #{i}"
        _req(m, "title", path, errs)
        _req(m, "credit", path, errs)
        _req(m, "date", path, errs)
        _date(m, "date", path, errs)
        _req(m, "google_drive_link", path, errs)
        gdl = (m.get("google_drive_link") or "").strip()
        if gdl and not _is_drive_file_link(gdl):
            errs.append(f"[{path}] google_drive_link must be a '.../file/d/<ID>/view' URL")

        mslug = (m.get("slug") or "").strip()
        if not mslug:
            errs.append(f"[{path}] internal error: media slug not generated")
        else:
            tmpl = MEDIA_SLUG_RE_TMPL.format(date=re.escape((m.get("date") or "").strip()),
                                             vslug=re.escape(vslug))
            if not re.match(tmpl, mslug):
                errs.append(f"[{path}] media slug '{mslug}' does not match '<date>-<source>-{vslug}-NN'")

    return errs
